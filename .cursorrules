# Cursor AI Rules for Brebaje

This file provides rules and context for Cursor AI when working with the Brebaje codebase.

## Project Overview

Brebaje is a zero-knowledge proof ceremony management platform built with:
- **Backend**: NestJS with TypeScript, SQLite, Sequelize ORM
- **Frontend**: Next.js 14 with App Router, TailwindCSS, React Query
- **CLI**: Commander.js with TypeScript ES modules
- **Monorepo**: pnpm workspaces with Lerna

## Code Style & Standards

### TypeScript

- Use strict TypeScript mode
- Prefer explicit types over `any` - use `unknown` or proper types
- Use interfaces for object shapes
- Use type aliases for unions and intersections
- Enable all strict compiler options

### Naming Conventions

- **Files**: `kebab-case.ts` (e.g., `user-service.ts`)
- **Classes**: `PascalCase` (e.g., `UserService`)
- **Functions/Variables**: `camelCase` (e.g., `getUserById`)
- **Constants**: `UPPER_SNAKE_CASE` (e.g., `MAX_RETRIES`)
- **Interfaces/Types**: `PascalCase` (e.g., `UserProfile`)

### Code Formatting

- Use Prettier (auto-formatted on save)
- Single quotes for strings
- Semicolons required
- 2-space indentation
- Trailing commas in multi-line structures
- Maximum line length: 80 characters (where practical)

### Import Organization

1. External dependencies (NestJS, React, etc.)
2. Internal modules (from `@brebaje/` packages)
3. Relative imports
4. Type-only imports (use `import type`)

Example:
```typescript
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

import type { User } from '../types';
import { UserService } from './user.service';
```

## Documentation Requirements

### TSDoc Comments

**All public APIs must have TSDoc comments.** This includes:
- Exported functions, classes, interfaces, and types
- Public methods and properties
- Complex algorithms or business logic
- Configuration options

**Required TSDoc format:**
```typescript
/**
 * Brief description of what the function/class does.
 *
 * @param paramName - Description of the parameter
 * @returns Description of the return value
 * @throws {ErrorType} Description of when this error is thrown
 *
 * @example
 * ```typescript
 * const result = await functionName(param);
 * ```
 */
```

**TSDoc validation is enforced via ESLint** - syntax errors will fail pre-commit hooks.

See `docs/TSDOC_GUIDE.md` for comprehensive TSDoc guidelines.

## Architecture Patterns

### Backend (NestJS)

- Follow NestJS module pattern: Controller → Service → Repository
- Use dependency injection for all services
- Create DTOs for request/response validation
- Use class-validator and class-transformer for validation
- Organize by feature (e.g., `users/`, `ceremonies/`, `contributions/`)

### Frontend (Next.js)

- Use App Router structure
- Server components by default, client components when needed
- Use React Query for server state management
- TailwindCSS for styling (utility-first approach)
- Organize components by feature

### CLI

- Modular command structure with Commander.js
- Use ScriptLogger for consistent logging
- Handle errors gracefully with user-friendly messages
- Support both interactive and non-interactive modes

## Testing Standards

- Write tests for all new features
- Use descriptive test names
- Follow AAA pattern (Arrange, Act, Assert)
- Mock external dependencies
- Test edge cases and error conditions
- Maintain or improve test coverage

## ESLint & Linting

- ESLint v9 flat config format (`eslint.config.mjs`)
- TSDoc syntax validation is enforced
- Prettier integration for formatting
- Pre-commit hooks run linting automatically

## Git & Commits

### Commit Message Format

Follow [Conventional Commits](https://www.conventionalcommits.org/):

```
<type>(<scope>): <subject>

<body>

<footer>
```

Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`

### Pre-commit Hooks

Before each commit:
1. ESLint runs (includes TSDoc validation)
2. Prettier formats code
3. Type checking (via ESLint)

## File Structure Guidelines

- One class/interface per file (when possible)
- Group related functionality together
- Use index files for public API exports
- Keep files focused and small (< 300 lines when possible)

## Error Handling

- Use appropriate error types (not generic Error)
- Provide meaningful error messages
- Log errors with context
- Handle errors at appropriate levels

## Security Considerations

- Never commit secrets or API keys
- Use environment variables for configuration
- Validate all user input
- Use parameterized queries for database operations
- Implement proper authentication and authorization

## Performance

- Optimize database queries
- Use caching where appropriate
- Minimize bundle size
- Lazy load when possible
- Profile before optimizing

## Common Patterns

### Service Pattern (Backend)

```typescript
@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
  ) {}

  /**
   * Finds a user by ID.
   *
   * @param id - The user's unique identifier
   * @returns The user object if found, null otherwise
   */
  async findById(id: number): Promise<User | null> {
    return this.userRepository.findOne({ where: { id } });
  }
}
```

### React Query Hook (Frontend)

```typescript
/**
 * Fetches user data.
 *
 * @param userId - The user's unique identifier
 * @returns React Query hook result with user data
 */
export function useUser(userId: number) {
  return useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
  });
}
```

## When Writing Code

1. **Always add TSDoc comments** for public APIs
2. **Follow naming conventions** strictly
3. **Use TypeScript types** - avoid `any`
4. **Write tests** for new features
5. **Run linting** before committing
6. **Keep functions small** and focused
7. **Use meaningful names** for variables and functions
8. **Handle errors** appropriately
9. **Update documentation** when changing APIs
10. **Follow existing patterns** in the codebase

## When Suggesting Changes

- Maintain consistency with existing code
- Consider backward compatibility
- Update related documentation
- Include tests for new features
- Follow the project's architecture patterns

## Project-Specific Context

### Domain Models

- **Users**: Authenticated via GitHub OAuth
- **Projects**: Container for related ceremonies
- **Ceremonies**: Time-bounded events with phases (SCHEDULED → OPENED → CLOSED → FINALIZED)
- **Circuits**: Individual zkSNARK circuits requiring trusted setup
- **Participants**: Users enrolled in ceremonies
- **Contributions**: Cryptographic contributions to circuit trusted setup

### Database

- Schema defined in `apps/backend/src/database/diagram.dbml`
- Models auto-generated from DBML
- Use Sequelize ORM with TypeScript

### Authentication

- GitHub OAuth device flow
- JWT tokens for session management
- Token stored securely (not in plain text)

## Resources

- [Developer Guide](./docs/DEVELOPER_GUIDE.md)
- [TSDoc Guide](./docs/TSDOC_GUIDE.md)
- [Contributing Guide](./docs/CONTRIBUTING.md)
- [Setup Guide](./docs/SETUP.md)
- [CLAUDE.md](./CLAUDE.md) - Additional project context

## Important Reminders

- **TSDoc is mandatory** for all public APIs
- **ESLint validation** runs on every commit
- **TypeScript strict mode** is enabled
- **Tests are required** for new features
- **Documentation** must be updated with code changes

